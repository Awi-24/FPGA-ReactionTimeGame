library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity reaction_game is
    Port (
        clk             : in  STD_LOGIC;
        reset           : in  STD_LOGIC;
        start_button    : in  STD_LOGIC;
        player_buttons  : in  STD_LOGIC_VECTOR(3 downto 0);
        start_led       : out STD_LOGIC;
        anode_select    : out STD_LOGIC_VECTOR(3 downto 0);
        segment_select  : out STD_LOGIC_VECTOR(6 downto 0)
    );
end reaction_game;

architecture Behavioral of reaction_game is

    -- Definição dos estados da FSM
    type state_type is (IDLE, RANDOM_DELAY, TIMING, WINNER, DISPLAY_WINNER, DISPLAY_TIME, HOLD_RESULT);
    signal current_state, next_state : state_type := IDLE;

    -- Sinais para os módulos
    signal debounced_start_button : STD_LOGIC;
    signal debounced_player_buttons : STD_LOGIC_VECTOR(3 downto 0);
    signal random_delay_done : STD_LOGIC;
    signal timer_start, timer_stop : STD_LOGIC;
    signal timer_reset : STD_LOGIC;
    signal reaction_time : unsigned(15 downto 0); -- Em milissegundos
    signal winner : unsigned(1 downto 0);
    signal display_value : unsigned(15 downto 0);

    -- Sinais de controle da FSM
    signal hold_counter : integer range 0 to 50000000 := 0; -- Para o estado HOLD_RESULT

begin

    -- Instanciação dos módulos
    debouncer_start : entity work.button_debouncer
        port map (
            clk => clk,
            button_in => start_button,
            button_out => debounced_start_button
        );

    debouncers_player : for i in 0 to 3 generate
        debouncer_inst : entity work.button_debouncer
            port map (
                clk => clk,
                button_in => player_buttons(i),
                button_out => debounced_player_buttons(i)
            );
    end generate;

    random_gen : entity work.random_delay
        port map (
            clk => clk,
            start => timer_start,
            delay_done => random_delay_done
        );

    timer : entity work.reaction_timer
        port map (
            clk => clk,
            reset => timer_reset,
            start => timer_start,
            stop => timer_stop,
            time_ms => reaction_time
        );

    display_driver : entity work.seven_segment_driver
        port map (
            clk => clk,
            value_to_display => display_value,
            anodes => anode_select,
            segments => segment_select
        );

    -- Lógica da Máquina de Estados Finitos
    process(clk, reset)
    begin
        if reset = '1' then
            current_state <= IDLE;
        elsif rising_edge(clk) then
            current_state <= next_state;
        end if;
    end process;

    process(current_state, debounced_start_button, random_delay_done, debounced_player_buttons, hold_counter)
    begin
        -- Padrões
        next_state <= current_state;
        start_led <= '0';
        timer_start <= '0';
        timer_stop <= '0';
        timer_reset <= '0';
        display_value <= (others => '0');

        case current_state is
            when IDLE =>
                display_value <= (others => '0');
                timer_reset <= '1';
                if debounced_start_button = '1' then
                    next_state <= RANDOM_DELAY;
                end if;

            when RANDOM_DELAY =>
                timer_start <= '1';
                if random_delay_done = '1' then
                    next_state <= TIMING;
                end if;

            when TIMING =>
                start_led <= '1';
                timer_start <= '1';
                for i in 0 to 3 loop
                    if debounced_player_buttons(i) = '1' then
                        timer_stop <= '1';
                        winner <= to_unsigned(i, 2);
                        next_state <= WINNER;
                    end if;
                end loop;

            when WINNER =>
                -- O tempo de reação já foi capturado pelo timer
                next_state <= DISPLAY_WINNER;

            when DISPLAY_WINNER =>
                display_value <= (0 => '1', others => '0') when winner = 0 else
                               (1 => '1', others => '0') when winner = 1 else
                               (1 => '1', 0 => '1', others => '0') when winner = 2 else
                               (2 => '1', others => '0') when winner = 3 else (others => '0');
                hold_counter <= 0;
                next_state <= DISPLAY_TIME;


            when DISPLAY_TIME =>
                display_value <= reaction_time;
                if hold_counter < 150000000 then -- Aproximadamente 3 segundos com clock de 50MHz
                    hold_counter <= hold_counter + 1;
                else
                    hold_counter <= 0;
                    next_state <= IDLE;
                end if;

        end case;
    end process;

end Behavioral;